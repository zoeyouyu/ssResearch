
### Start to explore just the PFMC pressure change (baseline removed) for subject s0007
```{r}
source(file = "Functions.R")
data_folders = list.files(pattern = "_csv")
folder = data_folders[1]
s0007data = process(folder)

data = s0007data[[2]]
data$id = 1:nrow(data)
```

### Let's have a look at sensor 1 traces and its peaks
```{r}
library(pracma)
# Set the minimal peak distance to be 100 data points (1 second apart) reference Nadia M. Hamad, 2013
# Set the minimal peak height to be 1 mmHg
peaks_p1 = findpeaks(data$p1,  minpeakheight = 1, minpeakdistance = 100)
plot(data$p1, type = "l")
points(peaks_p1[, 2], peaks_p1[, 1], pch = 15, col = "red")
```

#### Can I set a good threshold?
```{r}
top_3_peaks_p1 = findpeaks(data$p1, minpeakdistance = 500, npeaks = 3)
top_3_peaks_indices_p1 = top_3_peaks_p1[, 2]
plot(data$p1, type = "l")
points(top_3_peaks_p1[, 2], top_3_peaks_p1[, 1], pch = 15, col = "red")
text(top_3_peaks_p1[, 2] + 250, top_3_peaks_p1[, 1], as.character(top_3_peaks_p1[, 2]))
```

### Get 3 change points(timestamp) for sensor 1
```{r}
library(changepoint)

(p1.binseg = cpt.mean(data$p1, method = "BinSeg", Q = 6))
best.fit.cpts = cpts(p1.binseg)

plot(p1.binseg)
```



```{r}
best.fit.cpts
```

### Comment: After attempts on the whole dataset, we found that change point function worked pretty well for sensor 1, but not really for other sensors. The parameters are not consistent.
### Decide to stick to section each peaks method.

### Segment1 is from id 1 to first peak. Return the peak start point. (point 1)
```{r}
seg1.test = cpt.mean(data[1:top_3_peaks_indices_p1[1], "p1"])
point1 = cpts(seg1.test)
plot(seg1.test)
text(cpts(seg1.test), 0, cpts(seg1.test), font = 2)
```
### Segment2 is from point1 to second peak. Return the fisrt peak end point. (point 2)

#### Need to change the x axis
```{r}
seg2.test = cpt.mean(data[point1:top_3_peaks_indices_p1[2], "p1"])
point2 = cpts(seg1.test) + cpts(seg2.test)
plot(seg2.test)
text(cpts(seg2.test), 0, point2, font = 2)
```
### Segment3 is from point2 to second peak. Return the second peak start point. (point 3)

#### Need to change the x axis
```{r}
seg3.test = cpt.mean(data[point2:top_3_peaks_indices_p1[2], "p1"])
point3 = point2 + cpts(seg3.test)
plot(seg3.test)
text(cpts(seg3.test), -0.5, point3, font = 2)
```

### Segment4 is from point3 to third peak. Return the second peak end point. (point 4)

#### Need to change the x axis
```{r}
seg4.test = cpt.mean(data[point3:top_3_peaks_indices_p1[3], "p1"])
point4 = point3 + cpts(seg4.test)
plot(seg4.test)
text(cpts(seg4.test), 0, point4, font = 2)
```

### Segment5 is from point4 to third peak. Return the third peak start point. (point 5)

#### Need to change the x axis
```{r}
seg5.test = cpt.mean(data[point4:top_3_peaks_indices_p1[3], "p1"])
point5 = point4 + cpts(seg5.test)
plot(seg5.test)
text(cpts(seg5.test), 0.5, point5, font = 2)
```

### Segment6 is from point5 to the end. Return the third peak end point. (point 6)

#### Need to change the x axis
```{r}
seg6.test = cpt.mean(data[point5:nrow(data), "p1"])
point6 = point5 + cpts(seg6.test)
plot(seg6.test)
text(cpts(seg6.test), 0.5, point6, font = 2)
```




### For sensor 2, GET THE TOP 3 PEAKS
```{r}
top_3_peaks_p2 = findpeaks(data$p2,  minpeakheight = 1, minpeakdistance = 500, npeaks = 3)
plot(data$p2, type = "l")
points(top_3_peaks_p2[, 2], top_3_peaks_p2[, 1], pch = 15, col = "red")
text(top_3_peaks_p2[, 2] + 250, top_3_peaks_p2[, 1], as.character(top_3_peaks_p2[, 2]))
```
```{r}
(cpt.test2 = cpt.mean(data$p2, method = "BinSeg", minseglen = 1000, Q = 7))

cpoints.sensor2 = cpts(cpt.test2)

plot(cpt.test2)
```

### For sensor 3

```{r}
plot(data$p3, type = "l")
peaks3_p3 = findpeaks(data$p3, minpeakheight = 1, minpeakdistance = 500, npeaks = 3)
points(peaks3_p3[, 2], peaks3_p3[, 1], pch = 15, col = "red")
```

```{r}
(cpt.test3 = cpt.mean(data$p3, method = "BinSeg", Q = 6))
cpoints = cpts(cpt.test3)

plot(cpt.test3)
```




# For all datasets (8 sensors)
```{r}
data.matrix = as.matrix(t(data[-9:-10]))
```


```{r}
test.all = cpt.mean(data.matrix,  method = "BinSeg", Q = 7, minseglen = 700)

lapply(test.all, cpts)
```


### Comment: Smooth the data out, reduce the effect of the noise.

```{r}
data
```















