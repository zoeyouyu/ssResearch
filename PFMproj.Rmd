---
title: "PFMproj"
author: "Zoe Zhou"
date: "10/12/2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


10/12/2019 

This data set is RAW data from subjects(physios) doing certain exercises
||||||||||||||||||||||||||||||||Might need some cleaning|||||||||||||||||||||||||||||||||||||||

----------------------------------------- TASK -----------------------------------------------
We are looking for the peak pressure values among three contractions, to find which one or more than one sensors representing the active pelvic muscles. We are particularly interested in the variability of the result.

***************************************** Note *********************************************
--Each pressure measurement includes the __baseline atmosphere pressure__ due to the great sensitivity of the sensors. We might or might not need to exclude this baseline value during the investigation. Currently we are taking the value right (within 3-5 seconds) before each contraction to be treated as the initial pressure value. 
--All the timestamps for contractions and rest, are recorded manually by the user, saved in JSON files. 

~~ Pressure values are records at a frequency of 50 Hz. ~~
~~ So 50 measurements per second. ~~

11/12/2019 Corrected: We were using device _pfd0084_ which records measurements at a frequency of  __100 Hz__. So we have 100 measurements per second. 1 measurement every 10 milliseconds. 


***
##### Preparing packages
```{r}
# install.packages("tidyverse")
# install.packages("rjson")
# install.packages("quantmod")

library(tidyverse)
library(rjson)
library(quantmod)
```

------------------- For all data -----------------------------
===============================  Helper functions ==============  

###### A function that tidys up a given dataset
```{r}
tidy = function(data){
  data %>%
  gather(sensor, pressure, p1:p8) %>%
  mutate(sensor = as.factor(sensor))
}
```


###### A function to obtain all available exercise ids (as a list)
```{r}
get_id_list = function(){
  # Get the exercise list length
  N = length(exercise_list)
  
  # Initialise an empty id list
  id_list = vector("list", N)
  
  # Loop through the exercise list to get every exercise id
  for (i in (1:N)) {
    id_list[[i]] = exercise_list[[i]]$id
    i = i + 1
  }
  
  id_list 
  
}
```

###### A function that obtain the description for a rough input exercise name (id)
```{r}
get_description = function(id){
  id_list = get_id_list()

  # Get the exercise order in the list
  id_order = grep(id, id_list)
  
  if (length(id_order) == 0) {
    description = NULL
  } else {
    
  # Get the exercise
    exercise_list[[id_order]]
    
  # Get the description
  description = exercise_list[[id_order]]$activity
  }
  
  description
}
```


###### A function of extracting start/stop time for a given exercise
# (modified from the individual subject s0007 version)
```{r}
getrectime = function(folder, exercise){
  # Get the session json of this subject
  session = fromJSON(file = list.files(path = folder, pattern = "session.json", recursive = TRUE, full.names = TRUE))

  # Get the profile json file, so we have information about the exercises
  profile = fromJSON(file = list.files(path = folder, pattern = "profile", recursive = TRUE, full.names = TRUE))
  # or pattern = ".+(_)+.+.json"

  exercise_list = profile$exercise_groups[[1]]$exercises

  # Get the starting time from recordings
  rec = session$recordings
  start = rec[[1]]$start
  
  # Get the order of the exercise in exercise_order
  order = grep(exercise, session$exercise_order)
  
  # Get the pfmc exercise start and stop timestamps
  exercise_start = session$exercises[[order]]$start
  exercise_stop = session$exercises[[order]]$stop
  
  # Subtract the initial recording start timestamp to get the approximate time
  exercise_start_time = round((exercise_start - start) / 10) * 10
  exercise_stop_time = round((exercise_stop - start) / 10) * 10
  
  list(exercise_start_time, exercise_stop_time)
}
```

###### A function of subsetting data for a given time
```{r}
getsubdata = function(data, start, stop){
  
  if (start < min(data$rectime)){
    stop(paste0("Sorry, data missing for recording time before ", min(data$rectime), " s."))
  }
  
  if (stop > max(data$rectime)){
    stop(paste0("Sorry, data missing for recording time after ", max(data$rectime), " s."))
  }
  
  data %>% filter(rectime >= start, rectime <= stop)
}
```

An example of calling the above 2 functions
```{r}
# rectime = getrectime(exercise = "relax30s")
# relaxdata = getsubdata(data, rectime[[1]], rectime[[2]])
```

***

### Now define some functions to automatic the whole thing

###### A function plot pressure values vs time (in seconds), where the time variable is indicating how long after the this exercise has begun

```{r}
plot = function(exercisedata, name = NULL){
  # mutate a new time variable 
  # by subtract the recoring time varibale by its starting time (minimal value)
  # Note, there are some missingness
  exercisedata$time = exercisedata$rectime - min(exercisedata$rectime)
  
  timelength = max(exercisedata$time)
  
  # Default time gap is 1s
  gap = 1000
  
  # Take 5s as the gap if total time is greater than 30 seconds
  if (timelength > 30000) { gap = 5000 }
  
  # Take 10s as the gap if total time is greater than 100 seconds
  if (timelength > 100000) { gap = 10000 }
  
  # Take 50s as the gap if total time is greater than 30 seconds
  if (timelength > 500000) { gap = 50000 }

  if (is.null(name) == TRUE) {
    description = NULL
    } 
  else {
    description = paste("Instruction:", get_description(name)) 
    }

  exercisedata %>% 
    tidy() %>%
    ggplot(aes(x = time, y = pressure, color = sensor)) +
    geom_line(position = position_dodge(width = 0.2)) +
    scale_x_discrete(limits = seq(0, round(max(exercisedata$time)/1000)*1000, gap), 
                     labels = seq(0, round(max(exercisedata$time)/1000), gap/1000)) +
    labs(x = "Time (in s)", y = "Pressure (in mm Hg)",
         title = paste("Pressure change during the exercise of", name),
         caption = description) +
    scale_color_brewer(palette = "Set1") + 
    guides(color = guide_legend(override.aes = list(size = 5)))

}

```

###### Not so useful but exist ####
###### A function plot the pressure change vs rectime (in ms) (rectime is the original recording time variable in data)
```{r eval = FALSE}
plot2 = function(exercisedata, name = NULL){
  if (is.null(name) == TRUE) 
    {description = NULL} 
  else 
    {description = paste("Instruction:", get_description(name))}

  exercisedata %>% 
    tidy() %>%
    ggplot(aes(x = rectime, y = pressure, 
               group = sensor, color = sensor)) +
    geom_line(position = position_dodge(width = 0.2)) +
    labs(x = "Recording Time (in ms)", y = "Pressure (in mm Hg)",
         title = paste("Pressure change during the excise of", name),
         caption = description) +   
    scale_color_brewer(palette = "Set1") + 
    guides(color = guide_legend(override.aes = list(size = 5)))

}
```

***
##### Finding baseline: Rough Guess

As each sensor has a different initial pressure value at the start of the pfmc exercise, the patterns of pressure changes are not so easy-to-understand. Hence we should remove the baseline pressure values and focus on the changes. Then we can get a better idea of which sensor has the greatest change.

General Method:
Find a rest period of at least 2 seconds with relatively stable pressure values, average it out for each sensor and treat it as the baseline.

Question:
How to find this *stable rest period*?

Procedure:
We attempted 3 times taking 3 different rest periods. 
Attemp1: Take the first exercise, relax 30 seconds. 

Attempt2: Take all the time before the first contraction. Means when the device started recording, we get rest data, until the subject start to contract.

Attempt3: Take the 15s rest time within the pfmc exercise. 

After taking out the average pressure values for each sensor, all these 3 trials gave very similar output. Regarding to the negative values, they can be explained by the sucction of the sensor member, resulting the pressure decrease.

However, the 3rd attempt gave the most reliable initial value(closest to 0), so we will be using this approach for all subjects.

----------See R code from [s0007.Rmd] ("C:/Users/Pluie/Desktop/SS research/ssResearch/7542a8d335c2d356_7_csv/s0007/s0007.rmd")

###### A function to mutate a pressure `change` column
```{r}
baseline = function(data, relaxdata){
  newdata = sweep(data[-1], 2, colMeans(relaxdata[-1]))
  newdata$rectime = data$rectime
  newdata
}
```


###### A run-everything process function - return the pfmc datasets
```{r}
process = function(folder){
  # Get the data
  whole = read.csv(list.files(path = folder, pattern = ".csv", recursive = TRUE, full.names = TRUE))
  
  # Get the session json of this subject
  # session = fromJSON(file = list.files(path = folder, pattern = "session.json", recursive = TRUE, full.names = TRUE))
  
  # Get the profile json file, so we have information about the exercises
  # profile = fromJSON(file = list.files(path = folder, pattern = "profile", recursive = TRUE, full.names = TRUE))
  # or pattern = ".+(_)+.+.json"
  
  # exercise_list = profile$exercise_groups[[1]]$exercises

  # Rename columns
  colnames(whole) = c("rectime", paste0("p", 1:8), paste0("t", 1:8))

  data = whole %>% select(-(t1:t8))

  #list(plot(pfmcdata), plot2(pfmcdata))
  
  # Get the start/end time of the pfmc exercise
  name = "pfmc"
  rectime = getrectime(folder, name)
  
  # Get pfmc data
  pfmcdata = getsubdata(data, rectime[[1]], rectime[[2]])
  
  # Get the resting period - stable data
  attempt3 = getsubdata(data, rectime[[1]], rectime[[1]] + 15000)

  # Take out the baseline from data
  newdata = baseline(data, attempt3)
  
  # Subset the pfmc data
  pfmcchange = getsubdata(newdata, rectime[[1]], rectime[[2]])
  
  # Retutn pfmc dataset, one original, one change
  list(pfmcdata, pfmcchange)

}
```

##### Now call the big nice function and check out the graphic results
```{r}
# Find folders that contain our data
data_folders = list.files(pattern = "_csv")
folder = data_folders[1]

pfmcdatalist = lapply(data_folders, process)

for (l in pfmcdatalist) {
  print(lapply(l, plot))
}

```



###### ------------------Lets explore the peaks ------------------------######
```{r}

```



18/12/2019
Suggestion :
Principal component analysis (PCA)
changepoints (package)
findpeaks (function)

