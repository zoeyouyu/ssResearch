---
title: "s0007"
author: "Zoe Zhou"
date: "10/12/2019"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# Found the folder that contains patient data s0007
folders = list.files(pattern = "_csv")
folder = folders[grep("_7_", folders)]

# Process the folder, get df.list (containing 3 datasets)
source("Functions.R")
df.list = process(folder)
data = df.list[[1]]
```


```{r}
# Check where is the crazy data at the end
end = grep("FALSE", data[-1] < 800)[1]

# Get rid of that crazy part and plot
data[1:(end-50), ] %>% myplot(name = names(df.list)[1])
```

##### Remove the baseline and plot the whole
```{r}
myplot(df.list[[2]][1:(end-50), ], name = names(df.list)[2])
```

##### Get the pfmc data and plot it
```{r}
myplot(df.list[[3]], name = names(df.list)[3]) + theme_classic() 
#ggsave("PFMC - classic.png", width = 10, height = 5)
```
##### Remove the baseline and plot it
```{r}
myplot(df.list[[4]], name = names(df.list)[4]) + theme_classic()
```


##### Create a new time variable, and add a axis labelling in seconds
---Create a new time variable , by subtracting the recording time variable by its starting time (the minimal value)

```{r}
pfmcdata = df.list[[3]]
pfmcdata$time = pfmcdata$rectime - min(pfmcdata$rectime)
```


##### Data inspection
---Note, there are some missingness in the data (time gap is not always 10 ms) 

** This might cause a slipperage in data (a drastic drop)

** E.g. TIME = 1640	 to 1680 time gap is 40ms, we lost the data in between **
```{r}
recno = ifelse(diff(pfmcdata$rectime) == 10, "good", NA)
# Give the last one NaN
pfmcdata$isna = as.factor(c(recno, NaN))
summary(pfmcdata$isna)
```

Apparently, we have 15 missing values. But so far, it does not affect our plotting.


### For PFMC change data, we wanna dive closer to see each contraction
### To get smoothed.peak.df to reduce the effect of noise (the smoothed line captures the pattern of trace fairly well)

## Get the peak pressure values
```{r}
change = df.list[[4]]
change$peak = apply(change[, 1:8], 1, max)
```

## Smooth the peak  `span` is really important here!!!!!!!!!!

```{r}
tidydata = tidy(change)
lo.whole = loess(peak ~ rectime, data = tidydata, span = 0.1)
plot(tidydata$rectime, tidydata$peak, pch = 21, cex = 0.5)

lines(tidydata$rectime[order(tidydata$rectime)],
      predict(lo.whole)[order(tidydata$rectime)],
      col = "red", lwd = 2)
```


```{r}
# Get smoothed.peak.df
smoothed.peak.df = unique(data.frame(rectime = tidydata$rectime[order(tidydata$rectime)], 
                            peak = predict(lo.whole)[order(tidydata$rectime)]))
smoothed.peak.df$id = 1:nrow(smoothed.peak.df)

# Plot the smoothed peak line
ggplot(data = tidydata) +
  geom_line(aes(x = rectime, y = pressure, color = sensor)) +
  geom_line(data = smoothed.peak.df, aes(x = rectime, y = peak), size = 1) +
  labs(x = "Recording Time (in s)", y = "Pressure Change (in mm Hg)",
       title = "Pressure trace from all sensors with smoothed line of peak") + 
    scale_color_brewer(palette = "Set1") + 
  guides(color = guide_legend(override.aes = list(size = 5)))

```


#### Get the top n peaks.

## Before calling `findpeaks` function, set a threshold called noise to be ignored (not picked up as a peak - a potential event)
```{r}
# Get the baseline noise from the first 15 seconds of data
noise = change %>% 
  tidy() %>%
  filter(rectime < (min(change$rectime) + 15000)) %>%
  summarise(maxdiff = max(pressure) - min(pressure)) %>%
  as.numeric()

change %>%
  filter(rectime < (min(change$rectime) + 15000)) %>% plot2()
```

#### Note: changed minpeakdistane to 500 !!!!! Depends on the participant (time interval between contractions varies!!!!!!!!!!)
```{r}
top_n_peaks = findpeaks(smoothed.peak.df$peak, minpeakdistance = 500, minpeakheight = noise)
top_n_peaks_indices = sort(top_n_peaks[, 2])

### Check how many peaks we got
(n_peaks = length(top_n_peaks_indices))
```


```{r}
plot(smoothed.peak.df$peak, type = "l")
points(top_n_peaks[, 2], top_n_peaks[, 1], pch = 15, col = "red")
text(top_n_peaks[, 2] + 300, top_n_peaks[, 1], as.character(top_n_peaks[, 2]))
```

### Greedy method ###
#### Trying to get  `n_peaks*2` change points at once using Binary Segementation

```{r}
all.binseg = cpt.mean(smoothed.peak.df$peak, method = "BinSeg", Q = 10)
plot(all.binseg)
```



### Doing pretty well!!!!!!!!!! Good job greedy!!!!

```{r}
(greedy.fit = cpts(all.binseg))
```


## For whole data (8 sensors) - Back to our original data
```{r}
## Only taking the 6 points we want
mypoints = greedy.fit[c(1, 3, 4, 6, 7, 8)]
n_PFMC = 3

```

## Just double check if we actually get the changepoints right (can manually modify a bit here if needed)
```{r}
pfmc_start = seq(1, n_PFMC, 1)*2 - 1

pfmc_end = seq(1, n_PFMC, 1)*2

# Shift the ending time of contraction no.2, 15 points to the right (so the graph looks nicer)
mypoints[pfmc_end[2]] = mypoints[pfmc_end[2]] + 50

# Shift the starting time of contraction no.3, 30 points to the left (so the graph looks nicer)
mypoints[pfmc_start[3]] = mypoints[pfmc_start[3]] - 50

start.end.rectime = change$rectime[mypoints] 

plot2(change) + theme_void() +
  geom_vline(xintercept = start.end.rectime)

```

## Let's have a look at each individual event (a PFMC) !!!!

```{r}
for (i in 1:n_PFMC) {
  start = start.end.rectime[i*2 - 1]
  end = start.end.rectime[i*2]
  

  print(myplot(getsubdata(change, start, end), name = paste0("PFMC No.", i))  +
          theme_classic() + 
          theme(axis.text = element_text(face = "bold", size = 14),
                axis.title = element_text(face = "bold", size = 14)))

  #ggsave(paste0("PFMC No.", i, ".png"), height = 5, width = 8)
}

```





### Task: Averaging the peaks for each sensor !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#### Contraction NO.1
```{r}

```

